open StdLabels
open Printf

module Param = struct
  type t =
    | Dirfd
    | Path
    | Flags of string
    | Int
    | Perm

  let c_type = function
    | Dirfd   -> "int"
    | Path    -> "char*"
    | Flags _ -> "int"
    | Int     -> "int"
    | Perm    -> "int"

  let ml_type = function
    | Dirfd   -> "Fd.t"
    | Path    -> "string"
    | Flags s -> String.capitalize s ^ ".t list"
    | Int     -> "int"
    | Perm    -> "File_perm.t"

  let of_val t var =
    match t with
    | Dirfd | Int | Perm -> sprintf "Int_val(%s)" var
    | Flags s -> sprintf "caml_convert_flag_list(%s, shexp_%s_table)" var s
    | Path    -> sprintf "caml_strdup(String_val(%s))" var
end

module Result = struct
  type t = Unit | Fd
end

type stub = string * (string * Param.t) list * Result.t * bool (* available on OSX *)

let stubs : stub list =
  let open Param in
  let dir      = "dir"     , Dirfd           in
  let olddir   = "olddir"  , Dirfd           in
  let newdir   = "newdir"  , Dirfd           in
  let path     = "path"    , Path            in
  let oldpath  = "oldpath" , Path            in
  let newpath  = "newpath" , Path            in
  let at_flags = "flags"   , Flags "at_flag" in
  let perm     = "perm"    , Perm            in
  [ "openat"    , [dir; path; ("flags", Flags "open_flag"); perm           ], Fd   , true
  ; "faccessat" , [dir; path; ("mode", Flags "access_permission"); at_flags], Unit , true
  ; "fchmodat"  , [dir; path; perm;                                at_flags], Unit , true
  ; "fchownat"  , [dir; path; ("uid", Int); ("gid", Int);          at_flags], Unit , true
  ; "mkdirat"   , [dir; path; perm                                         ], Unit , true
  ; "unlinkat"  , [dir; path; at_flags                                     ], Unit , true
  ; "mkfifoat"  , [dir; path; perm                                         ], Unit , false
  ; "linkat"    , [olddir; oldpath; newdir; newpath;               at_flags], Unit , true
  ; "renameat"  , [olddir; oldpath; newdir; newpath                        ], Unit , true
  ; "symlinkat" , [oldpath; newdir; newpath                                ], Unit , true
  ]

let pr fmt = printf (fmt ^^ "\n")

let gen_stub ((name, params, result, on_osx) : stub) =
  let args ~prefix =
    List.map params ~f:(fun (v, _) -> prefix ^ v) |> String.concat ~sep:", "
  in
  pr "";
  if not on_osx then begin
    pr "#if defined(__APPLE__)";
    pr "";
    pr "NA(%s)" name;
    pr "";
    pr "#else";
    pr "";
  end;
  pr "CAMLprim value shexp_has_%s() { return Val_true; }" name;
  pr "";
  pr "CAMLprim value shexp_%s(%s)" name (args ~prefix:"value v_");
  pr "{";
  pr "  CAMLparam%d(%s);" (List.length params) (args ~prefix:"v_");
  List.iter params ~f:(fun (v, t) ->
    pr "  %s %s;" (Param.c_type t) v);
  let result_var =
    match result with
    | Unit -> "res"
    | Fd   -> "fd"
  in
  pr "  int %s;" result_var;
  pr "";
  List.iter params ~f:(fun (v, t) ->
    if t = Param.Path then
      pr "  caml_unix_check_path(v_%s, %S);" v name);
  let longest_arg =
    List.fold_left params ~init:0 ~f:(fun acc (v, _) -> max (String.length v) acc)
  in
  List.iter params ~f:(fun (v, t) ->
    pr "  %-*s = %s;" longest_arg v (Param.of_val t ("v_" ^ v)));
  pr "";
  pr "  caml_enter_blocking_section();";
  pr "  %s = %s(%s);" result_var name (args ~prefix:"");
  pr "  caml_leave_blocking_section();";
  pr "";
  List.iter params ~f:(fun (v, t) ->
    if t = Param.Path then
      pr "  caml_stat_free(%s);" v);
  let arg_for_errors =
    List.fold_left params ~init:"Nothing" ~f:(fun acc (v, t) ->
      if t = Param.Path then
        "v_" ^ v
      else
        acc)
  in
  pr "  if (%s == -1) uerror(%S, %s);" result_var name arg_for_errors;
  pr "  CAMLreturn(%s);"
    (match result with
     | Unit -> "Val_unit"
     | Fd   -> "Val_int(fd)");
  pr "}";
  if not on_osx then begin
    pr "";
    pr "#endif"
  end

let gen_external ((name, params, result, _on_osx) : stub) =
  pr "";
  pr "external %s" name;
  match params with
  | [] -> assert false
  | (v, t) :: rest ->
    pr "  :  %s:%s" v (Param.ml_type t);
    List.iter rest ~f:(fun (v, t) ->
      pr "  -> %s:%s" v (Param.ml_type t));
    pr "  -> %s"
      (match result with
       | Unit -> "unit"
       | Fd   -> "Fd.t");
    pr "  = \"shexp_%s\"" name

let gen_has_external ((name, _, _, _) : stub) =
  pr "";
  pr "external has_%s : unit -> bool = \"shexp_has_%s\"" name name;
  pr "let has_%s = has_%s ()" name name

let () =
  let argv = Array.to_list Sys.argv in
  let comment =
    sprintf "This file was generated by: %s"
      (String.concat ~sep:" " argv)
  in
  match argv with
  | [_; "c"] ->
    pr "/* %s */" comment;
    pr "";
    pr "#include \"common.h\"";
    pr "";
    pr "#if defined(_WIN32)";
    pr "";
    List.iter stubs ~f:(fun (name, _, _, _on_osx) ->
      pr "NA(%s);" name);
    pr "";
    pr "#else /* defined(_WIN32) */";
    List.iter stubs ~f:gen_stub;
    pr "";
    pr "#endif /* defined(_WIN32) */"
  | [_; "ml"] ->
    pr "(* %s *)" comment;
    pr "";
    pr "open Types";
    List.iter stubs ~f:gen_external;
    List.iter stubs ~f:gen_has_external
  | _ ->
    eprintf "Usage: %s [c|ml]\n" Sys.argv.(0);
    exit 2
